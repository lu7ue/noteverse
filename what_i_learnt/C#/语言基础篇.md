> 本篇笔记 **核心内容** 包括：
>> 类型系统
>> 变量与常量
>> 数组、列表 与 字典
>> 运算符
>> 控制结构

# 类型系统

## 1. 核心基础数据类型

游戏中的每一个数值、状态和文字，都需要用特定的数据类型来存储和表示。

| 类型 | 含义与描述 | 游戏开发中的典型用途 |
| :--- | :--- | :--- |
| **int** | 整数。表示没有小数部分的数字。 | 玩家血量(health)、分数(score)、金币数量(coins)。 |
| **float** | 单精度浮点数。表示有小数部分的数字。 | 移动速度(moveSpeed)、攻击力(attackPower)、冷却时间(cooldown)。注意：赋值时必须在数字后加f。 |
| **double** | 双精度浮点数。比float精度更高，表示范围更大。 | 用于需要极高精度的复杂数学计算。在常规游戏逻辑中，float更为常用。 |
| **bool** | 布尔值。只有两个值：true（真）或 false（假）。 | 是否存活(isAlive)、是否在地面(isGrounded)、技能是否就绪(isSkillReady)。是逻辑判断的基础。 |
| **string** | 字符串。表示一串文本。 | 玩家名称(playerName)、对话文本(dialogue)、物品描述(itemDescription)。注意：必须用双引号""包围。 |

## 2. var 关键字：类型推断

var让编译器根据赋值自动推断变量类型，目的是简化代码书写。初期最好使用标准写法以熟悉类型，熟练后可多用var使代码更简洁。

```c#
标准写法：
int health = 100;
float speed = 5.5f;
string name = "战士";

使用 var 的简化写法（效果与上面完全一致）：
var health = 100;    // 编译器推断为 int
var speed = 5.5f;    // 编译器推断为 float
var name = "战士";   // 编译器推断为 string
```

## 3. 类型转换

在游戏开发中，经常需要将数据在不同类型间转换。

### a) 隐式转换
由编译器自动完成，是从"小"类型到"大"类型的安全转换。
```c#
int score = 100;
float totalScore = score; // int 被自动转换为 float，数据无丢失
```

### b) 显式转换（强制转换）
需要手动指定类型，用(目标类型)的语法。可能会丢失数据。
```c#
float preciseHealth = 87.5f;
int displayHealth = (int)preciseHealth; // float 被强制转换为 int，小数部分丢失。结果为 87。
```
在UI上显示血量条时，经常需要将精确的float血量强制转换为int来显示。

### c) 使用 Convert 类
最常用的转换工具，尤其在字符串与数值互转时。它的容错性更好：null -> 默认值，而不是崩溃。

字符串 -> 数值 (例如：从输入框读取数值)：
```c#
string input = "50";
int damage = Convert.ToInt32(input); // 50
```

字符串 -> 数值 (例如：输入框可能为空)
```c#
string nullStr = null;
int hp = Convert.ToInt32(nullStr);   // 0，不会报错
```

数值 -> 字符串 (例如：将分数显示在UI上)：
```c#
int score = 1500;
string scoreText = Convert.ToString(score); // 1500
```

### d) 使用 Parse 方法
与Convert类似，专门针对字符串的转换，更直接，但要求输入合法。null 或格式错误都会抛异常。
```c#
string goldText = "999";
int gold = int.Parse(goldText); // 字符串 "999" 被转换为整数 999

// int.Parse(null); // 抛 ArgumentNullException
// int.Parse("abc"); // 抛 FormatException
```

# 变量与常量

## 1. 变量：游戏中的数据容器

变量是程序中存储数据的基本单元，可以理解为游戏世界中的各种"容器"。

### 变量声明与初始化

**基本语法：** `数据类型 变量名 = 初始值;`

```c#
int playerHealth = 100;           // 玩家生命值
float moveSpeed = 5.5f;           // 移动速度
bool isGamePaused = false;        // 游戏暂停状态
string playerName = "冒险者";     // 玩家名称
```

**多种声明方式：**
```c#
// 先声明后赋值
int score;
score = 0;

// 声明时直接初始化
float jumpForce = 12.0f;

// 同时声明多个同类型变量
int coins, gems, keys;
coins = 10;
gems = 5;
```

### 变量命名规则

使用有意义的英文单词，让代码自解释。

**合法命名：**
```c#
int playerHealth;      // 描述性名称
float _moveSpeed;      // 以下划线开头
bool isGrounded;       // 驼峰命名法
string itemName123;    // 包含数字

**非法命名：**
int 123score;         // 数字开头
float move-speed;      // 包含连字符
string class;         // 使用关键字
```

## 2. 变量作用域：数据的可见范围

作用域决定了变量在代码中的可见性和生命周期。

### 局部变量
在方法或代码块内部声明，只在声明它的范围内有效。

```c#
void UpdatePlayer()
{
    int localExp = 100;    // 局部变量，只在UpdatePlayer方法内可见
    localExp += 10;        // 正确：在作用域内使用
}
// localExp = 50;         // 错误：超出作用域，无法访问
```

### 成员变量（字段）
在类内部声明，在整个类中可见。
```c#
class Player
{
    int health = 100;      // 成员变量，整个Player类中可见
    string name = "战士";
    
    void TakeDamage()
    {
        health -= 10;      // 正确：在类内部可以访问
    }
}
```

### 块级作用域
在 {} 代码块中声明的变量。
```c#
void CheckCollision()
{
    if (isColliding)
    {
        int collisionCount = 0;  // 块级变量
        collisionCount++;
    }
    // collisionCount = 5;      // 错误：超出块作用域
}
```

### 循环变量作用域
```c#
for (int i = 0; i < 10; i++)
{
    // i 在循环体内可见
    Console.WriteLine(i);
}
// i = 5;  // 错误：i 在循环外不可见
```

## 3. 常量

常量用于存储程序运行期间不会改变的值，使用 const 关键字定义。基本语法：`const 数据类型 常量名 = 值;`

```c#
const int MAX_PLAYER_HEALTH = 100;        // 最大生命值
const float GRAVITY = 9.8f;               // 重力常数
const string GAME_VERSION = "1.0.0";      // 游戏版本
const bool DEBUG_MODE = true;             // 调试模式开关
```

### 常量特点
- 必须在声明时赋值
- 赋值后不能再修改
- 通常使用全大写命名
- 编译时就被确定值

### 常量使用场景
```c#
class GameSettings
{
    public const int MAX_ENEMIES = 50;           // 最大敌人数
    public const float ITEM_RESPAWN_TIME = 30.0f; // 物品重生时间
    public const string SAVE_FILE_PATH = "saves/"; // 存档路径
}

void SpawnEnemy()
{
    if (currentEnemies < GameSettings.MAX_ENEMIES)
    {
        // 生成敌人
    }
}
```

### 常量使用建议

```c#
// 使用常量代替魔法数字
if (playerHealth > MAX_PLAYER_HEALTH)  // 清晰
if (playerHealth > 100)                // 不清晰：100是什么？
```

## 4. 接收用户输入

在游戏中常用于调试、控制台命令等场景。

### 基本输入方法

```c#
// 读取整数输入
Console.Write("请输入生命值: ");
int inputHealth = Convert.ToInt32(Console.ReadLine());

// 读取字符串输入
Console.Write("请输入玩家名称: ");
string inputName = Console.ReadLine();
```

### 游戏中的实际应用

```c#
void CheatCodeHandler()
{
    Console.Write("输入作弊码: ");
    string cheatCode = Console.ReadLine();
    
    if (cheatCode == "GODMODE")
    {
        playerHealth = 9999;
        Console.WriteLine("上帝模式激活！");
    }
}
```

# 数组、列表与字典

## 1. 数组(Array)：固定大小的集合

数组是存储**相同类型**元素的**固定大小**集合，通过索引访问元素。

### 数组的特点
- **固定大小**：创建后不能改变大小
- **连续内存**：元素在内存中连续存储
- **快速访问**：通过索引直接访问，速度快

### 数组的基本使用

**声明与初始化：**
```c#
// 声明并初始化数组
int[] enemyHealths = new int[5];          // 创建包含5个元素的数组
string[] itemNames = new string[3];       // 字符串数组

// 声明时直接赋值
int[] scores = { 100, 85, 92, 78, 65 };   // 直接初始化
float[] positions = new float[] { 1.5f, 2.3f, 0.8f }; // 另一种语法

// 数组存对象（看下面的 Enemy 类代码）
Enemy[] enemies = new Enemy[2];
enemies[0] = new Enemy("骷髅兵", 50);
enemies[1] = new Enemy("魔法师", 30);

// --- --- --- --- ------ --- --- --- ------ --- --- --- ------ --- --- --- ---

// Enemy 类的构造函数定义了两个参数， 所以新建一个 Enemy 实例需要两个值
class Enemy
{
    public string Name;
    public int HP;

    public Enemy(string name, int hp)
    {
        Name = name;
        HP = hp;
    }

    public void Update()
    {
        Console.WriteLine($"{Name} 正在行动，HP={HP}");
    }
}
```

**访问和修改元素：**
```c#
// 通过索引访问（索引从0开始）
enemyHealths[0] = 100;    // 第一个敌人血量
enemyHealths[1] = 150;    // 第二个敌人血量
enemyHealths[4] = 200;    // 最后一个敌人血量

int firstScore = scores[0];     // 获取第一个分数
scores[2] = 95;                // 修改第三个分数

// 修改数组中某个对象的值
enemies[0].HP = 80;             // 修改第一个敌人的血量
Console.WriteLine(enemies[0].Name + " 当前HP: " + enemies[0].HP);
```

**遍历数组：**
```c#
// 使用for循环
for (int i = 0; i < enemyHealths.Length; i++)
{
    Console.WriteLine($"敌人{i}的血量: {enemyHealths[i]}");
}

// 使用foreach循环（更简洁）
foreach (int score in scores)
{
    Console.WriteLine($"分数: {score}");
}
```

## 2. 列表(List<T>)：动态大小的集合

列表是**动态数组**，可以**自动调整大小**，比数组更灵活。

### 列表的基本使用

**声明与初始化：**

```c#
// 需要 using System.Collections.Generic; -> List<T> 就定义在 System.Collections.Generic 这个命名空间里。
List<int> playerScores = new List<int>();        // 创建空列表
List<string> inventory = new List<string>();     // 物品库存列表

// 声明时初始化
List<float> enemyPositions = new List<float> { 1.2f, 3.4f, 5.6f };
```

**常用操作：**

```c#
// 添加元素
playerScores.Add(100);           // 添加到末尾
playerScores.Insert(0, 120);     // 在指定位置插入

// 访问元素
int firstScore = playerScores[0]; // 通过索引访问
playerScores[1] = 90;            // 修改元素

// 删除元素
playerScores.Remove(100);        // 删除指定元素，只删掉第一个100
playerScores.RemoveAll(x => x == 100); // 删掉所有值为 100 的元素
playerScores.RemoveAt(0);        // 删除指定位置的元素

// 其他常用方法
bool contains = playerScores.Contains(85);    // 检查是否包含
int count = playerScores.Count;               // 获取元素数量（数组用 .Length）
playerScores.Clear();                         // 清空列表
```

**遍历列表：**

```c#
// 使用for循环
for (int i = 0; i < inventory.Count; i++)
{
    Console.WriteLine($"物品{i}: {inventory[i]}");
}

// 使用foreach循环
foreach (int score in playerScores)
{
    Console.WriteLine($"玩家分数: {score}");
}
```

### 游戏开发应用实例

**管理敌人列表：**

```c#
// enemies 里存的是 多个 Enemy 对象，每个对象里自带属性和方法（看下面的 Enemy 类代码）
List<Enemy> enemies = new List<Enemy>();

// 生成敌人时添加
enemies.Add(new Enemy("骷髅兵", 50));   // 把一个 Enemy 对象放进列表
enemies.Add(new Enemy("魔法师", 30));   // 再放一个

// 敌人死亡时移除
enemies.Remove(deadEnemy);

// 遍历所有敌人
foreach (Enemy enemy in enemies)
{
    enemy.Update();
}

// --- --- --- --- ------ --- --- --- ------ --- --- --- ------ --- --- --- ---

// Enemy 类的构造函数定义了两个参数， 所以新建一个 Enemy 实例需要两个值
class Enemy
{
    public string Name;
    public int HP;

    public Enemy(string name, int hp)
    {
        Name = name;
        HP = hp;
    }

    public void Update()
    {
        Console.WriteLine($"{Name} 正在行动，HP={HP}");
    }
}
```

## 3. 字典(Dictionary<TKey, TValue>)：键值对集合

字典通过**键**来快速查找**值**，每个**键必须是唯一**的。

### 字典的基本使用

**声明与初始化：**

```c#
// Dictionary<TKey, TValue> 也在 System.Collections.Generic 命名空间里
Dictionary<string, int> playerStats = new Dictionary<string, int>();
Dictionary<int, string> itemDatabase = new Dictionary<int, string>();

// 声明时初始化
Dictionary<string, float> gameSettings = new Dictionary<string, float>
{
    ["musicVolume"] = 0.8f,
    ["sfxVolume"] = 1.0f,
    ["mouseSensitivity"] = 2.5f
};
```

**常用操作：**

```c#
// 添加键值对
playerStats.Add("Health", 100);
playerStats.Add("Mana", 50);
playerStats["Stamina"] = 80;     // 另一种添加方式：如果 Stamina 这个 key 不存在，则新增 { "Stamina", 80 }；如果存在，则修改为  { "Stamina", 80 }

// 访问值
int health = playerStats["Health"];          // 通过键获取值（key 是唯一的，所以 playerStats["Health"] 也是唯一的）
playerStats["Mana"] = 75;                    // 修改值

// 删除键值对
playerStats.Remove("Stamina");

// 其他常用方法
bool contain = playerStats.ContainsKey("Health");          // 检查键是否存在
int count = playerStats.Count;       // 返回键值对数量
playerStats.Clear();             // 清除所有键值对
```

**遍历：**

```c#
// 遍历字典
foreach (KeyValuePair<string, int> stat in playerStats)
{
    Console.WriteLine($"{stat.Key}: {stat.Value}");
}

// 只遍历键或值
foreach (string key in playerStats.Keys)
{
    Console.WriteLine($"属性: {key}");
}

foreach (int value in playerStats.Values)
{
    Console.WriteLine($"数值: {value}");
}
```

### 游戏开发应用实例

**物品系统：**

```c#
// key 类型是 int → 代表物品的 ID（例如 1、2、3）；value 类型是 Item → 每个 key 对应一个 Item 对象
Dictionary<int, Item> items = new Dictionary<int, Item>();   // Item 类的构造函数定义了三个参数：string name, string description, int price

// 每次 new Item(...) 都会生成一个完整的 Item 对象，然后存入字典对应的 key。
items[1] = new Item("生命药水", "恢复50点生命值", 25);
items[2] = new Item("魔法药水", "恢复30点魔法值", 30);
items[3] = new Item("力量戒指", "增加10点攻击力", 100);

// 通过ID快速查找物品
Item potion = items[1]; // 根据ID 1 找到对应的 Item 对象
Console.WriteLine(potion.Name); // 输出 "生命药水"
```

## 4. 三种集合的对比与选择

| 特性 | 数组(Array) | 列表(List<T>) | 字典(Dictionary<K,V>) |
|------|-------------|---------------|---------------------|
| **大小** | 固定 | 动态 | 动态 |
| **访问方式** | 数字索引 | 数字索引 | 键 |
| **查找速度** | O(1) | O(n)查找值 | O(1)通过键 |
| **内存效率** | 高 | 中等 | 较低 |
| **使用场景** | 固定数量的同类对象（元素数量固定且已知；需要最高性能；例如：地图格子、固定技能栏） | 动态数量的对象集合（元素数量会变化；需要按顺序处理元素；例如：敌人列表、背包物品、任务队列） | 键值对数据（需要通过唯一标识快速查找；数据是键值对形式；例如：玩家数据、物品数据库、配置设置） |


# 运算符

## 1. 算术运算符：游戏数值计算

算术运算符用于基本的数学运算（数值计算和更新），是游戏开发中最常用的运算符。

### 基本算术运算

**加减乘除：**

```c#
int health = 100;
int damage = 25;
health = health - damage;    // 血量减少，结果为75

float speed = 5.0f;
speed = speed * 1.2f;        // 速度提升20%，结果为6.0f

int coins = 50;
coins = coins / 5;           // 平均分给5个玩家，每个10金币
```

**取模运算（求余数）：**

```c#
int playerCount = 8;
int teams = playerCount % 3;  // 8除以3余2，所以 teams = 2；可用于分组

// 当 frameCount 能被 60 整除时，更新一次，即每隔 60 帧更新一次
int frameCount = 157;
bool shouldUpdate = (frameCount % 60 == 0); // 取 frameCount 除以 60 的余数，再判断余数是否为 0，返回的结果是 true 或 false
```

### 自增自减运算符

**前缀与后缀的区别：**

```c#
int ammo = 10;

// 后缀：先使用原值，再自增
int currentAmmo = ammo++;    // ammo先赋值给currentAmmo，currentAmmo = 10, 然后ammo再运算从10变成11

// 前缀：先自增，再使用新值  
int newAmmo = ++ammo;        // ammo先从11变成12, 然后再赋值给newAmmo，newAmmo = 12
```

## 2. 关系运算符：条件判断基础

关系运算符用于比较两个值（条件比较和判断），返回布尔结果（true/false）。

### 比较运算

**基本比较：**

```c#
int playerHealth = 75;
int enemyDamage = 30;

bool isAlive = playerHealth > 0;           // 检查是否存活
bool canSurvive = playerHealth > enemyDamage; // 检查能否承受伤害
bool isCritical = enemyDamage >= 50;       // 检查是否为致命伤害（>= 的优先级高于 = ，因此不需要打括号）
```

## 3. 逻辑运算符：复杂条件组合

逻辑运算符用于组合多个布尔条件。

### 逻辑与(&&)、或(||)、非(!)

**逻辑与(&&)：所有条件都为真**

```c#
bool hasKey = true;
bool doorUnlocked = false;

if (hasKey && doorUnlocked)  // 两个条件都要满足
{
    OpenDoor();
}

// 攻击条件检查
bool inRange = (distance < attackRange);
bool hasAmmo = (currentAmmo > 0);
bool canSeeTarget = IsTargetVisible();

if (inRange && hasAmmo && canSeeTarget)
{
    FireWeapon();
}
```

**逻辑或(||)：至少一个条件为真**

```c#
bool isPaused = false;
bool isGameOver = true;

if (isPaused || isGameOver)  // 任意一个条件满足
{
    StopGameTime();
}

// 输入检测
bool keyPressed = Input.GetKey(KeyCode.Space);
bool mouseClicked = Input.GetMouseButton(0);

if (keyPressed || mouseClicked)
{
    PerformAction();
}
```

**逻辑非(!)：取反**

```c#
bool isGameRunning = true;

if (!isGameRunning)  // 如果游戏不在运行
{
    ShowMainMenu();
}

// 敌人状态检查
if (!enemy.IsAlive)  // 如果敌人不存活
{
    SpawnLoot();
}
```

## 4. 赋值运算符：简洁的数值更新

赋值运算符提供了一种简洁的方式来更新变量值。

### 复合赋值运算

**常用赋值运算符：**

```c#
int health = 100;

health += 25;    // 等同于 health = health + 25 (治疗)
health -= 30;    // 等同于 health = health - 30 (受伤)
health *= 2;     // 等同于 health = health * 2 (双倍血量)
health /= 4;     // 等同于 health = health / 4 (四分之一)
```

**游戏开发实例：**

```c#
// 玩家获得经验
experience += enemyXP;           // 增加经验值
playerLevel += 1;               // 升级
gold -= itemPrice;              // 购买物品
damage *= criticalMultiplier;   // 暴击伤害

// 连续操作
score += 100;                   // 得分
multiplier *= 1.1f;             // 连击倍数增加
cooldownTimer -= Time.deltaTime; // 冷却时间减少
```

## 5. 条件运算符(三元运算符)：简洁的条件赋值

条件运算符提供了一种简洁的方式来进行条件判断和赋值。

### 基本语法
`条件 ? 值1 : 值2` -> 条件为 true 时，表达式的结果是 值1；条件为 false 时，表达式的结果是 值2。

**游戏中的应用：**

```c#
// 根据血量显示状态
string healthStatus = (health > 50) ? "健康" : "危险";

// 伤害计算
int finalDamage = (isCriticalHit) ? baseDamage * 2 : baseDamage;

// 显示文本
string ammoText = (ammo > 0) ? $"弹药: {ammo}" : "需要装弹";

// 选择音效
AudioClip sound = (isPlayer) ? playerHitSound : enemyHitSound;
```

## 6. 运算符优先级：执行顺序规则

当表达式中包含多个运算符时，按照优先级顺序执行。

### 常见优先级顺序
1. 括号 () - 最高优先级
2. 自增/自减 ++ --
3. 乘除 * / %
4. 加减 + -
5. 比较 < > <= >=
6. 相等 == !=
7. 逻辑与 &&
8. 逻辑或 ||
9. 赋值 = += -= 等 - 最低优先级

### 优先级案例

```c#
// 使用括号明确优先级
int result1 = 10 + 5 * 2;      // 结果是20 (5*2先执行)
int result2 = (10 + 5) * 2;    // 结果是30 (括号优先)

// 复杂条件判断
bool shouldAttack = (distance < range) && (ammo > 0) || meleeWeapon; // 等同于：((distance < range) && (ammo > 0)) || meleeWeapon
```


# 控制结构

## 1. 条件判断：if/else 语句

条件判断用于根据不同的条件执行不同的代码路径。

### 基本 if 语句

**单一条件判断：**

```c#
int playerHealth = 75;

if (playerHealth > 0)
{
    Console.WriteLine("玩家存活");
    UpdatePlayer();
}
```

**if-else 结构：**

```c#
if (playerHealth <= 0)
{
    PlayDeathAnimation();
    ShowGameOverScreen();
}
else
{
    ContinueGameplay();
}
```

### 多条件判断

**if-else if-else 链：**

```c#
int score = 850;

if (score >= 1000)
{
    Console.WriteLine("S级评价！");
    AwardBonusItems();
}
else if (score >= 800)
{
    Console.WriteLine("A级评价");
    AwardStandardItems();
}
else if (score >= 600)
{
    Console.WriteLine("B级评价");
}
else
{
    Console.WriteLine("需要继续努力");
}
```

**嵌套 if 语句：**

```c#
if (player.IsAlive)
{
    if (player.HasWeapon)
    {
        if (player.Ammo > 0)
        {
            player.Shoot();
        }
        else
        {
            player.Reload();
        }
    }
    else
    {
        player.Punch();
    }
}
```

## 2. switch 语句：多分支选择

switch 语句用于基于一个变量的多个可能值执行不同的代码块。

### 基本 switch 语法

**游戏状态管理：**

```c#
GameState currentState = GameState.Playing;

switch (currentState)
{
    case GameState.Menu:
        ShowMainMenu();
        break;
    case GameState.Playing:
        UpdateGameplay();
        break;
    case GameState.Paused:
        ShowPauseMenu();
        break;
    case GameState.GameOver:
        ShowGameOverScreen();
        break;
    default:
        Debug.Log("未知游戏状态");
        break;
}
// 如果 currentState 不是 Menu/Playing/Paused/GameOver 这些值 → default 执行，打印 "未知游戏状态"
```

**武器类型处理：**

```c#
WeaponType equippedWeapon = WeaponType.Sword;

switch (equippedWeapon)
{
    case WeaponType.Sword:
        damage = 25;
        attackSpeed = 1.2f;
        break;
    case WeaponType.Bow:
        damage = 15;
        attackSpeed = 0.8f;
        break;
    case WeaponType.Staff:
        damage = 30;
        attackSpeed = 1.5f;
        break;
    default:
        damage = 10;
        attackSpeed = 1.0f;
        break;
}
// 如果未来加了新武器但没在 switch 里写 case → default 会给一个 安全的默认数值
```

### 高级 switch 用法

**多个 case 合并：**

```c#
int enemyType = 2;

switch (enemyType)
{
    case 1:
    case 2:
    case 3:
        // 处理普通敌人
        SpawnCommonEnemy();
        break;
    case 4:
    case 5:
        // 处理精英敌人
        SpawnEliteEnemy();
        break;
    case 6:
        // 处理Boss
        SpawnBoss();
        break;
}
```

## 3. 循环结构：重复执行代码

### for 循环

**固定次数循环：**

```c#
// 生成10个敌人
for (int i = 0; i < 10; i++)
{
    SpawnEnemy();
}

// 初始化游戏物品数组
for (int i = 0; i < inventory.Length; i++)
{
    inventory[i] = new Item();
}
```

**遍历数组/列表：**

```c#
int[] scores = { 100, 85, 92, 78, 65 };

for (int i = 0; i < scores.Length; i++)
{
    Console.WriteLine($"玩家{i + 1}得分: {scores[i]}");
    totalScore += scores[i];
}
```

### foreach 循环

**遍历集合元素：**

```c#
List<string> inventoryItems = new List<string> { "剑", "盾", "药水", "钥匙" };

foreach (string item in inventoryItems)
{
    Console.WriteLine($"拥有物品: {item}");
}
```

### while 循环
while 循环是 先判断条件再决定是否执行，可能一次都不执行

**条件循环：**

```c#
int ammo = 30;

while (ammo > 0)
{
    Shoot();
    ammo--;
    Console.WriteLine($"剩余弹药: {ammo}");
}
```

**游戏主循环：**

```c#
bool isGameRunning = true;

while (isGameRunning)
{
    ProcessInput();
    UpdateGameLogic();
    RenderGraphics();
    
    // 检查退出条件
    if (playerHealth <= 0 || Input.GetKey(KeyCode.Escape))
    {
        isGameRunning = false;
    }
}
```

### do-while 循环
do-while 保证 循环体至少执行一次，即 先执行一次循环体，再判断条件是否继续循环。

**至少执行一次：**

```c#
int playerChoice;

do
{
    ShowMenu();                  // 显示菜单
    playerChoice = GetPlayerInput();  // 获取玩家输入
    ProcessChoice(playerChoice);      // 处理玩家选择
} while (playerChoice != 0);   // 条件判断：不等于0就继续循环（true → 再执行一次循环体；false → 循环结束）
```

## 4. 循环控制语句

### break 语句

**提前退出循环：**

```c#
for (int i = 0; i < 100; i++)
{
    if (foundTarget)
    {
        break; // 找到目标后立即退出循环
    }
    SearchForTarget();
}
```

**在 switch 中终止case：**

```c#
switch (weaponType)
{
    case WeaponType.Sword:
        damage = 25;
        attackSpeed = 1.2f;
        break; // 必须的，终止这个case
    case WeaponType.Bow:
        damage = 15;
        attackSpeed = 0.8f;
        break;
}
```

### continue 语句

**跳过当前迭代：**

```c#
for (int i = 0; i < enemies.Count; i++)
{
    if (!enemies[i].IsAlive)
    {
        continue; // 敌人死了，直接跳过本次循环，进入下一次 i++，下方的 enemies[i].Update() 不会被执行
    }
    
    enemies[i].Update(); // 活的敌人 → 条件 false → 执行 Update()
}

// 循环每个敌人：如果死了 -> 跳过；如果活着 -> 更新
```

**处理有效物品：**

```c#
foreach (Item item in inventory)
{
    if (item == null || item.IsBroken)
    {
        continue; // 如果 槽位空 或 物品损坏 → continue → 跳过本次循环，进入下一次 i++，下方的  item.Render() 不会被执行
    }
    
    item.Render(); // 条件不满足（即物品存在且没坏） → 执行 item.Render()
}

// 循环每个物品：如果空或坏 -> 跳过；否则 -> 渲染
```

## 5. 游戏开发综合应用

### 敌人生成系统

```c#
public void SpawnWave(int waveNumber)
{
    int enemyCount = waveNumber * 5;
    
    for (int i = 0; i < enemyCount; i++)
    {
        Vector3 spawnPosition = GetRandomSpawnPoint();
        
        // 每5波增加一个精英敌人
        if (waveNumber % 5 == 0 && i == 0)
        {
            SpawnEliteEnemy(spawnPosition);
            continue;
        }
        
        SpawnNormalEnemy(spawnPosition);
    }
}
```

### 游戏状态管理器

```c#
public class GameStateManager
{
    public void UpdateGameState()
    {
        switch (currentState)
        {
            case GameState.Menu:
                UpdateMenu();
                break;
                
            case GameState.Playing:
                UpdateGameplay();
                
                // 检查游戏结束条件
                if (playerHealth <= 0 || timeRemaining <= 0)
                {
                    currentState = GameState.GameOver;
                }
                break;
                
            case GameState.Paused:
                UpdatePauseMenu();
                break;
                
            case GameState.GameOver:
                UpdateGameOver();
                break;
        }
    }
}
```

### 输入处理系统

```c#
public void ProcessPlayerInput()
{
    while (HasInputEvents())
    {
        InputEvent currentEvent = GetNextInputEvent();
        
        switch (currentEvent.Type)
        {
            case InputType.Movement:
                HandleMovement(currentEvent);
                break;
                
            case InputType.Attack:
                if (CanAttack())
                {
                    HandleAttack(currentEvent);
                }
                break;
                
            case InputType.Interact:
                HandleInteraction(currentEvent);
                break;
                
            default:
                Debug.Log("未知输入类型");
                break;
        }
    }
}
```

### 物品系统处理

```c#
public void ProcessInventory()
{
    foreach (Item item in playerInventory)
    {
        // 跳过空槽位
        if (item == null) continue;
        
        // 检查物品类型并执行相应逻辑
        switch (item.Category)
        {
            case ItemCategory.Weapon:
                UpdateWeaponDurability(item);
                break;
                
            case ItemCategory.Consumable:
                if (item.IsExpired)
                {
                    RemoveItem(item);
                    continue; // 跳过已移除的物品
                }
                break;
                
            case ItemCategory.Quest:
                UpdateQuestProgress(item);
                break;
        }
        
        // 渲染物品
        item.Render();
    }
}
```