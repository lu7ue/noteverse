> 本篇笔记 **核心内容** 包括：
>> 方法基础
>> 参数与返回类型
>> 方法重载
>> 异常处理
>> 异步

## 1. 方法基础：定义与调用

方法是封装代码逻辑的基本单元，让代码更模块化和可重用。

### 方法的基本结构

**方法定义语法：** `访问修饰符 返回类型 方法名(参数列表)`

```c#
<访问修饰符> <返回值类型> <方法名>(参数列表)
{
   // 方法体
   return 返回值; // 当不需要 return 时，定义方法时的 返回值类型 应该是 void
}

```

**游戏开发实例：**

```c#
// 无返回值方法
public void PlaySoundEffect()
{
    audioSource.Play();
    Debug.Log("播放音效");
}

// 有返回值方法
public int CalculateDamage()
{
    int baseDamage = weaponDamage + strength;
    return baseDamage;
}

// 带参数的方法
public void HealPlayer(int healAmount)
{
    currentHealth += healAmount;
    if (currentHealth > maxHealth)
    {
        currentHealth = maxHealth;
    }
}
```

### 方法的调用

**调用实例方法：**

```c#
Player player = new Player();

// 调用无返回值方法
player.MoveForward();

// 调用有返回值方法
int damage = player.CalculateDamage();

// 调用带参数方法 - 无返回值
player.HealPlayer(50);

// 调用带参数方法 - 有返回值
int newHealth = player.HealPlayer(50); 
```

## 2. 静态方法：无需实例的方法

普通方法（非静态）属于 对象实例，必须先创建对象才能调用；静态方法属于 类本身，和具体对象无关，可以直接用 类名 调用，不用创建对象。

> 当 需要访问或修改对象的属性/状态（方法要操作具体对象的属性） 时，定义 普通方法。当 不依赖任何对象状态，只想实现 工具、计算或通用功能 时，定义 静态方法。

### 静态方法定义

**工具类方法：**

```c#
public class GameMath
{
    // 静态方法 - 计算两点距离
    public static float CalculateDistance(Vector3 pointA, Vector3 pointB)
    {
        return Vector3.Distance(pointA, pointB);
    }
    
    // 静态方法 - 生成随机数范围
    public static int RandomRange(int min, int max)
    {
        Random rnd = new Random();
        return rnd.Next(min, max);
    }
}
```

**游戏管理器方法：**

```c#
public class GameManager
{
    private static int score = 0;   // score 是 静态字段，属于类本身，不属于某个对象
    
    // 静态方法 - 更新分数
    public static void AddScore(int points)
    {
        score += points;   // 修改的是类的静态字段
        UpdateScoreUI();
    }
    
    // 静态方法 - 获取游戏状态 - 这个方法只读取全局状态，也不依赖任何对象
    public static bool IsGamePaused()
    {
        return Time.timeScale == 0f;
    }
}
```

### 静态方法调用

```c#
// 直接通过类名调用，无需创建实例
float distance = GameMath.CalculateDistance(playerPos, enemyPos);
int randomDamage = GameMath.RandomRange(10, 20);
GameManager.AddScore(100);
```

## 3. 参数与返回类型

### 参数传递方式

**值参数（默认）：** 调用时传入的是变量的“副本”，就算在方法内部修改 damageAmount 值也不会改变调用者那边传入的变量，不是因为没有返回这个值，而是因为这个 参数值 是复制品。

```c#
public void TakeDamage(int damageAmount)
{
    currentHealth -= damageAmount; // 原始值不会被影响
}
```

**引用参数（ref）：** 调用时传入的是 变量的引用（调用前 变量 必须初始化并赋值），方法里操作的是原来的变量，因此即使方法没有返回值，外面的变量也会被修改。

```c#
public void SwapPositions(ref Vector3 pos1, ref Vector3 pos2)
{
    Vector3 temp = pos1;
    pos1 = pos2;
    pos2 = temp; // 会修改原始变量
}
```

**输出参数（out）：** 和引用参数（ref）一样，但调用前不需要初始化，而方法内部必须能给它赋值。

```c#
// 方法返回 bool 来表示操作是否成功，out 负责返回具体值
public bool TryParseInt(string input, out int result)
{
    // 尝试把字符串转换成整数
    return int.TryParse(input, out result);
}

// 使用
int number;
if (TryParseInt("123", out number))
{
    Console.WriteLine("转换成功: " + number);
}
else
{
    Console.WriteLine("转换失败");
}

// 调用 TryParseInt("123", out number)：
// 1. 方法尝试把 "123" 转成整数；
// 2. 成功 → 返回 true，number 被赋值为 123；
// 3. 失败 → 返回 false，number 也会被赋一个默认值（通常是 0）
```

### 返回类型

**基本返回类型：**

```c#
public int GetPlayerLevel()
{
    return playerLevel; // 返回整数
}

public string GetPlayerName()
{
    return playerName; // 返回字符串
}

public bool IsAlive()
{
    return currentHealth > 0; // 返回布尔值
}
```

**返回自定义类型：**

```c#
public Weapon GetEquippedWeapon()
{
    return equippedWeapon; // 返回武器对象
}

public List<Item> GetInventoryItems()
{
    return inventory; // 返回列表
}
```

## 4. 方法重载：同名不同参

方法重载允许在同一个类中定义多个同名方法，但参数列表不同。

调用时，编译器根据你传入的参数匹配对应的方法。

### 重载示例

**攻击方法重载：**

```c#
public class CombatSystem
{
    // 基础攻击
    public void Attack()
    {
        // 使用默认武器攻击
        weapon.Attack();
    }
    
    // 指定目标攻击
    public void Attack(Enemy target)
    {
        weapon.Attack(target);
    }
    
    // 指定目标和伤害倍率
    public void Attack(Enemy target, float damageMultiplier)
    {
        int damage = (int)(baseDamage * damageMultiplier);
        target.TakeDamage(damage);
    }
    
    // 使用特定技能攻击
    public void Attack(string skillName)
    {
        Skill skill = GetSkill(skillName);
        skill.Execute();
    }
}

// 使用：
CombatSystem combat = new CombatSystem();

combat.Attack();                      // 调用无参数版本
combat.Attack(enemy);                 // 调用带 Enemy 参数的版本
combat.Attack(enemy, 1.5f);           // 调用带 Enemy + float 的版本
combat.Attack("Fireball");            // 调用带 string 参数的版本
```

## 5. 异常处理：错误恢复机制

异常处理让程序在遇到错误时能够优雅地恢复，而不是崩溃。

### 基本异常处理

**try-catch 结构：**
只是捕获并处理异常：try → 放可能出错的操作，catch → 捕获指定类型的异常，处理错误。

```c#
public void LoadGameData(string filePath)
{
    try
    {
        // 尝试读取文件
        string data = File.ReadAllText(filePath);
        ParseGameData(data);
    }
    catch (FileNotFoundException ex)
    {
        // 文件不存在
        Debug.LogError($"存档文件不存在: {ex.Message}");
        CreateNewGame();
    }
    catch (IOException ex)
    {
        // IO错误
        Debug.LogError($"读取文件时出错: {ex.Message}");
    }
    catch (Exception ex)
    {
        // 其他所有异常
        Debug.LogError($"未知错误: {ex.Message}");
    }
}
```

**finally 块：**
finally 是无论是否发生异常，都会执行的代码。有资源需要释放 / 收尾操作，就用 finally。

```c#
public void SaveGame()
{
    StreamWriter writer = null;
    try
    {
        writer = new StreamWriter(saveFilePath);
        writer.Write(SerializeGameData()); // 如果 Write 出错，Close() 永远不会执行
    }
    catch (Exception ex)
    {
        Debug.LogError($"保存失败: {ex.Message}");
    }
    finally
    {
        // 无论是否发生异常，都会执行
        writer?.Close();      // 保证 无论成功还是异常 都会执行
        Debug.Log("保存流程结束");
    }
}

// StreamWriter 打开文件后，必须关闭。如果写在 try 里，一旦发生异常，后续关闭操作可能不会执行，导致资源泄露。
```

## 6. 异步编程：async/await

异步编程让耗时操作不会阻塞主线程，保持游戏流畅。

### 基本异步方法

**简单的异步操作：**

```c#
public async Task LoadSceneAsync(string sceneName)
{
    // 显示加载界面
    ShowLoadingScreen();
    
    try
    {
        // 异步加载场景
        AsyncOperation operation = SceneManager.LoadSceneAsync(sceneName);
        
        // 等待加载完成，但不阻塞主线程
        await operation;
        
        Debug.Log("场景加载完成");
    }
    finally
    {
        // 隐藏加载界面
        HideLoadingScreen();
    }
}
```

**带进度的异步加载：**

```c#
public async Task LoadAssetsWithProgress()
{
    var assetsToLoad = new List<string> { "player", "enemies", "environment" };
    
    foreach (string asset in assetsToLoad)
    {
        // 模拟异步加载
        await Task.Delay(1000);
        
        // 更新进度
        UpdateLoadingProgress(asset);
        
        Debug.Log($"已加载: {asset}");
    }
}
```

**多个异步任务并行：**

```c#
public async Task InitializeGameAsync()
{
    // 并行启动多个加载任务
    Task uiTask = LoadUIAssetsAsync();
    Task audioTask = LoadAudioAssetsAsync();
    Task levelTask = LoadLevelDataAsync();
    
    // 等待所有任务完成
    await Task.WhenAll(uiTask, audioTask, levelTask);
    
    Debug.Log("所有资源加载完成，游戏就绪");
}
```

**超时控制：**

```c#
public async Task<bool> ConnectToServerAsync(string address, int timeoutSeconds = 10)
{
    try
    {
        // 设置超时
        var timeoutTask = Task.Delay(TimeSpan.FromSeconds(timeoutSeconds));
        var connectTask = EstablishConnection(address);
        
        // 等待连接完成或超时
        var completedTask = await Task.WhenAny(connectTask, timeoutTask);
        
        if (completedTask == timeoutTask)
        {
            throw new TimeoutException("连接服务器超时");
        }
        
        return await connectTask;
    }
    catch (TimeoutException ex)
    {
        Debug.LogWarning(ex.Message);
        return false;
    }
}
```

## 7. 游戏开发综合应用

### 角色能力系统

```c#
public class PlayerAbilities
{
    // 方法重载：不同攻击方式
    public void Attack() { /* 普通攻击 */ }
    public void Attack(string skillName) { /* 技能攻击 */ }
    public void Attack(Enemy target, bool isCritical) { /* 指定目标攻击 */ }
    
    // 异步方法：施法吟唱
    public async Task CastSpellAsync(string spellName)
    {
        ShowCastingBar();
        
        try
        {
            // 模拟吟唱时间
            await Task.Delay(2000);
            
            // 执行法术效果
            ExecuteSpell(spellName);
        }
        catch (Exception ex)
        {
            Debug.LogError($"施法失败: {ex.Message}");
            InterruptCasting();
        }
        finally
        {
            HideCastingBar();
        }
    }
}
```

### 游戏存档系统

```c#
public class SaveSystem
{
    // 静态方法：快速保存
    public static async Task QuickSaveAsync()
    {
        try
        {
            string saveData = SerializeGameState();
            await File.WriteAllTextAsync("quicksave.json", saveData);
            Debug.Log("快速保存成功");
        }
        catch (IOException ex)
        {
            Debug.LogError($"保存失败: {ex.Message}");
            throw; // 重新抛出异常
        }
    }
    
    // 异常处理：加载存档
    public static GameState LoadGame(string savePath)
    {
        try
        {
            if (!File.Exists(savePath))
            {
                throw new FileNotFoundException("存档文件不存在");
            }
            
            string saveData = File.ReadAllText(savePath);
            return DeserializeGameState(saveData);
        }
        catch (FileNotFoundException ex)
        {
            Debug.LogWarning(ex.Message);
            return CreateNewGame();
        }
        catch (Exception ex)
        {
            Debug.LogError($"加载存档时出错: {ex.Message}");
            return null;
        }
    }
}
```